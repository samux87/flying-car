<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>writeup.html</title>

</head>

<body>

<h1>Project: Building an Estimator</h1>

<h3>Vic Sperry, Udacity Flying Car Nanodegree, 25 Nov 2018</h3>

<p><img src="./misc/Baby-honey-badger-1.jpg" alt="There should be an image here, but I can't find it." title="" /></p>

<h2><a href="https://review.udacity.com/#!/rubrics/1807/view">Rubric</a> Items</h2>

<h2>Writeup</h2>

<p>This is the writeup.</p>

<h2>Implement Estimator</h2>

<h3>1. Determine Standard Deviation of Measurement Noise</h3>

<table border="1">
  <tr><th>CRITERIA</th><th>MEETS SPECIFICATIONS</th></tr>
  <tr>
    <td>Determine the standard deviation of the measurement noise of both GPS X data and Accelerometer X data.</td>
    <td>The calculated standard deviation should correctly capture ~68% of the sensor measurements. Your writeup should describe the method used for determining the standard deviation given the simulated sensor measurements.</td>
  </tr>
</table>

<p>The first step is to take a look at the csv files, config/log/Graph[12].txt These are the time-stamped GPS inertial X-position readouts, sampled at 10 Hz, and the time-stamped accelerometer body frame X-acceleration readouts, sampled at 200 Hz (but see note at end of this section). To find the mean and standard deviation, I read the data into OpenOffice Calc and used the AVERAGE() amd STDEV() functions. Here are some screen captures.<br /></p>

<p><img src="./misc/Graph1.png" alt="There should be an image here, but I can't find it." title="" /> <img src="./misc/Graph2.png" alt="There should be an image here, but I can't find it." title="" />
<br /><br />
Following the instructions in the project README under Step 1: Sensor Noise, part 4:<br />
"Plug in your result into the top of config/06_Sensornoise.txt. Specially, set the values for MeasuredStdDev_GPSPosXY and MeasuredStdDev_AccelXY to be the values you have calculated."</p>

<p>When I plugged in the values shown in screen captures, the IMU data was at 68% and passed the test, <span style="color:red">but the GPS data was at about 75% and didn't pass</span>. I speculated that needed more GPS samples, so I ran scenario_6 for 100 seconds instead of 10 seconds and re-calculated the standard deviation for the GPS.</p>

<p>This time I got:<br />
<span style="color:red"><code>Std Dev = 0.6908</code></span><br /></p>

<p>Plugging this new value back into the 06_Sensornose.txt file allowed the test to pass:<br /><br />
<code>(fcnd) [1214] jaguar: CPPEstSim</code><br />
<code>SIMULATOR!</code><br />
<code>Select main window to interact with keyboard/mouse:</code><br />
<code>LEFT DRAG / X+LEFT DRAG / Z+LEFT DRAG = rotate, pan, zoom camera</code><br />
<code>W/S/UP/LEFT/DOWN/RIGHT - apply force</code><br />
<code>C - clear all graphs</code><br />
<code>R - reset simulation</code><br />
<code>Space - pause simulation</code><br />
<code>Simulation #1 (../config/06_SensorNoise.txt)</code><br />
<code>Simulation #2 (../config/06_SensorNoise.txt)</code><br />
<code>PASS: ABS(Quad.GPS.X-Quad.Pos.X) was less than MeasuredStdDev_GPSPosXY for 68% of the time</code><br />
<code>PASS: ABS(Quad.IMU.AX-0.000000) was less than MeasuredStdDev_AccelXY for 68% of the time</code><br />
<code>Simulation #3 (../config/06_SensorNoise.txt)</code><br />
<code>PASS: ABS(Quad.GPS.X-Quad.Pos.X) was less than MeasuredStdDev_GPSPosXY for 68% of the time</code><br />
<code>PASS: ABS(Quad.IMU.AX-0.000000) was less than MeasuredStdDev_AccelXY for 68% of the time</code><br /></p>

<p><img src="./misc/scenario6.png" alt="There should be an image here, but I can't find it." title="" />
<br \><br \>
Note: Looking at the timestamps in the simulated IMU data, the sensor seems to be sampled every 0.005 sec (200 Hz), but when checking my answers against the simulaiton parameters in SimulatedSensors.txt, the IMU's dt is given as 0.002 (500 Hz). I'm not sure which to trust, and need to keep this in mind going forward.</p>

<h3>2. Implement a Better Rate Gyro Scheme</h3>

<table border="1">
  <tr><th>CRITERIA</th><th>MEETS SPECIFICATIONS</th></tr>
  <tr>
    <td>Implement a better rate gyro attitude integration scheme in the UpdateFromIMU() function.</td>
    <td>The improved integration scheme should result in an attitude estimator of < 0.1 rad for each of the Euler angles for a duration of at least 3 seconds during the simulation. The integration scheme should use quaternions to improve performance over the current simple integration scheme.</td>
  </tr>
</table>

<p><br />
The goal is to improve the IMU/accelerometer complementary filter such that the filter makes more-accurate predictions.</p>

<p>The first thing I did was to study the code to ensure I understood it. As given to me, it was the same algorithm we had implemented in the python exercise. It was a linear function, because the values from the rate gyros were being used as-is to predict the next set of Euler angles, which is adequate if the pitch and roll angles are close to zero. But it can be made better by making the function non-linear, which in this case means to get the euler angles and body rates into the same reference frame before integrating the rates to produce new euler angle estimates.</p>

<p>The second half of the function involves fusing the IMU estimations with the accelerometer estimations. This is how a complimentary filter works. The accelerometer-based estimations will be noisy, but they don't suffer from drift. The IMU-based estimations will be more accurate, but involve integrations, so will accumulate errors and drift over time. I checked over this "given" part of the code to ensure that I thought it was correct. I rewrote some code here for clarity, but didn't change its functionality.</p>

<p>Hovever, I noticed that <code>attitudeTau</code>, as configured in config/QuadEstimatorEKF.txt, was being set to 100, which -- based on my experience with the python exercise -- seemed much too high. So I changed it to 0.05 (about 25 times dtIMU). Other than that, I didn't change the "given" code.</p>

<p>I jumped right in and implemented something that defined a quaternion for the airframe attitude, and used it to rotate the body rates into the inertial frame before doing the integration, and this seemed to work -- sort-of -- but it wasn't good enough so I abandoned this approach.</p>

<p>The README suggested looking at the Udacity paper <a href="https://www.overleaf.com/read/vymfngphcccj">Estimation for Quadrotors</a>, section 7.1.2, "Nonlinear Complementary Filter", and I spent quite a lot of time studying this section, but there were too many truths left un-written, and I eventually gave up on this.</p>

<p>Eventually I took a look at the IntegrateBodyRate() function in the Quaternion class, and I instantly recognized equation (43) from the Udacity paper, and everything made sense and fell into place. I was on the right track in the beginning. I defined a quaternion for the attitude of the airframe relative to the inertial frame, and call its IntegrateBodyRate() function, passing in the un-rotated gyro data (in the body frame) and the dtIMU, and it will update the quaternion to reflect the next prediction. All that's left is to convert the new quaternion back to Euler angles, and those angles can be handed directly to the sensor fusion part of the code.</p>

<p>I quickly found out that the setting of <code>attitudeTau = 0.05</code> is no good for this filter, and found that the default value of 100 worked just fine.</p>

<p>And this test passes.</p>

<p><img src="./misc/step2.png" alt="There should be an image here, but I can't find it." title="" /></p>

<h3>3. Implement Prediction Step</h3>

<table border="1">
  <tr><th>CRITERIA</th><th>MEETS SPECIFICATIONS</th></tr>
  <tr>
    <td>Implement all of the elements of the prediction step for the estimator.</td>
    <td>The prediction step should include the state update element (PredictState() function), a correct calculation of the Rgb [sic] prime matrix, and a proper update of the state covariance. The acceleration should be accounted for as a command in the calculation of gPrime. The covariance update should follow the classic EKF update equation.</td>
  </tr>
</table>

<h4>3.1 Implement g()</h4>

<p>I took a look at how the graphs were behaving before I made any changes. Upper graph had true_y, est_y, true_vel_y, est_vel_y. Both estimates were flat-lined at zero, and the actual values were updating normally. Similar for the other graph, but for z.</p>

<p>Next step is to implement QuadEstimatorEKF::PredictState(), which is what we've been calling the g() function. In the Udacity paper <a href="https://www.overleaf.com/read/vymfngphcccj">Estimation for Quadrotors</a>, it is equation (49) in section 7.2, "Transition Model".</p>

<p>Before constructing the parts of the matricies, I compared the given Rbg matrix (48) to its supposed source, Diebel, equation (67). It's supposed to be the inverse of this matrix. That makes sense, because (67) gives the rotation matrix that maps Euler angles (inerial) to the body frame, and we want to go the other way (body to inertial). And... it checks out. (48) is the inverse of (67). Now, since PredictState() already has a quaternion, attitude, for the body rotation in the inertial frame, Rbg is just attitude.RotationMatrix_IwrtB().</p>

<p>The control input, u_t is described in the paper. See "Estimation for Quadrotors" equation (37), u_t is our control input. It is a 4-element vector, xb_dot_dot, yb_dot_dot, zb_dot_dot, psi_dot. The b_dot_dot vars are the accelerations in the body frame, given by parameter accel, and psi_dot is the yaw rate in the inertial frame. However, in this code, the yaw is predicted in UpdateFromIMU(), so we don't update it here, and we don't need psi_dot.</p>

<p>I decided to call the two matricies in the g() equation (49) "mga" (left-most) and "mgb" (right-most). As I implemented the code, however, I realized that I didn't need mgb. Most of it drops away. All I really need is attitude.RotationMatrix_IwrtB(), which gets multiplied by the accel param * dt, and this is added to the three velocity components of mga.</p>

<p>Once I had implemented this function, I re-ran scenario 8, and I got results similar to those shown in the project README.</p>

<p><img src="./misc/step3_0.png" alt="There should be an image here, but I can't find it." title="" /></p>

<h4>3.2 Add noise and implement Rbg'</h4>

<p>Ran scenario 9, and saw that the predicted X position and predicted X velocity were diverging from zero, even though the quad copters were all hovering and not changing X position.</p>

<p>To calculate Rbg', reference the Udacity paper, equation (52), which the authors claim is the partial derivative of the Rbg matrix with respect to psi. I verified this with sympy. Then it was just a matter of carefully and painfully laying out the matrix in GetRbgPrime().</p>

<p><img src="./misc/step3_1.png" alt="There should be an image here, but I can't find it." title="" /></p>

<h4>3.3 Implement Predict()</h4>

<p>Here's what I need to implement:</p>

<p><img src="./misc/predict.png" alt="There should be an image here, but I can't find it." title="" /></p>

<p>u_bar_t is already supplied by:<br />
<code>VectorXf newState = PredictState(ekfState, dt, accel, gyro);</code><br />
... which is assigned to ekfState at the bottom of the function. So that's done already.</p>

<p>I need to build G_t (aka gPrime) from RbgPrime. This is given in the Udacity document as equation (51). A good deal of this is constructed for me already because gPrime has already been set to the identity matrix. I need to fill in a few delta_ts. The only tricky part are the terms that use RbgPrime. Each of these takes a row from RbgPrime, takes the dot product with u_t, resulting in a scaler, then multiplies by delta_t.</p>

<p>Sigma_t-1 is the current ekfCov, which I will update. Q_t is class variable Q, which has already been constructed from config files.</p>

<p>The rest is just implementing the equation that calculates the new Sigma_t, which is assigned to ekfCov.</p>

<h4>3.4 Tune QPosXYStd and QVelXYStd</h4>

<p>This was a matter of running scenario 09_PredictionCov, and experimenting to get graphs similar to what was shown in the README.</p>

<p><img src="./misc/step3_4.png" alt="There should be an image here, but I can't find it." title="" /></p>

<h3>4. Implement Magetometer Update</h3>

<table border="1">
  <tr><th>CRITERIA</th><th>MEETS SPECIFICATIONS</th></tr>
  <tr>
    <td>Implement the magnetometer update.</td>
    <td>The update should properly include the magnetometer data into the state. Note that the solution should make sure to correctly measure the angle error between the current state and the magnetometer value (error should be the short way around, not the long way).</td>
  </tr>
</table>

<h4>4.1 Tune QYawStd</h4>

<p>Following the README, I ran scenario 10_MagUpdate and noted that the estimated Yaw error was climbing out of the standard deviation boundaries (white line). I increased QYawStd from 0.05 to 0.08, and the graph now looks similar to what is shown in the README.</p>

<p><img src="./misc/step4_1.png" alt="There should be an image here, but I can't find it." title="" /></p>

<h4>4.2 Implement Magnetometer update function UpdateFromMag()</h4>

<p>Refer to Udacity paper section 7.3.2. It says we read yaw directly from the sensor, and it's in the global frame. That's not what Angela said in the section on sensors -- she said the magnetometer would measure the North vector in the body frame. But if we're measuring yaw directly, I don't need roll and pitch here. I just need to implement the update function:</p>

<p><img src="./misc/update.png" alt="There should be an image here, but I can't find it." title="" /></p>

<p>But this has already been implemented in function Update(), so it's just a matter of passing in the correct matricies. The only tricky part to this function is normalizing the estimated state. When yaw is near -/+ PI, there is a discontinuity, and the estimated state may be, for example PI+0.1, and the measured value may be, for example, -PI-0.1. These two values are fairly close to each other, but mathematically, they are almost 2PI radians apart, which looks like an estimation error. One way to fix this is to test if the values have differing signs. If so, and the values are near PI or -PI, add or subtract 2PI to/from the estimation.</p>

<p>After implementing this function, I got good results, passed the tests, and did not have to re-tune QYawStd.</p>

<p><img src="./misc/step4_2.png" alt="There should be an image here, but I can't find it." title="" /></p>

<h3>5. Implement GPS Update</h3>

<table border="1">
  <tr><th>CRITERIA</th><th>MEETS SPECIFICATIONS</th></tr>
  <tr>
    <td>Implement the GPS update.</td>
    <td>The estimator should correctly incorporate the GPS information to update the current state estimate.</td>
  </tr>
</table>

<p>Now we're on to scenario 11_GPSUpdate. This is about following the README and experimenting with various changes, moving from ideal estimator + ideal IMU to my estimator + ideal IMU, to my estimator + realistic IMU, etc. Until finally implementing the GPS Update function using the matricies defined in Udacity paper section 7.3.1, and tuning the result.</p>

<h4>5.1 Ideal estimator and ideal IMU</h4>

<p>When I ran 11_GPSUpdate with an ideal estimator and ideal IMU, the quad copter makes a nice square at a consistent altitude. On the bottom graph, they've added new values quad.est.e.pos is the estimated position error. quad.est.s.z is the estimated standard deviation of Z (altitude). As time goes on, quad.est.e.pos drifts a lot and true y vs est y gets worse and worse.</p>

<h4>5.2 My estimator</h4>

<p>Now I switch to use my estimator instead of an ideal estimator. The quad plane flies fairly well for a while until the accumulated errors throw the estimations off.</p>

<h4>5.3 Realistic IMU</h4>

<p>Next, we introduce a realistic IMU with noise. Now flight becomes terribly off course, but I can read the standard deviations from the bottom graph and tune to the noise.</p>

<h4>5.4 Tune the process noise model</h4>

<p>quad.est.s.z seems to trend toward 2, so I made QPosZStd = 2. quad.est.s.y seems to trend toward 0.8, so I made QPosXYStd = 0.8, and continued this process for QVelXYStd, QVelZStd, QYawStd. I settled on these values:</p>

<p><code>QPosXYStd = .8</code><br />
<code>QPosZStd  = 2</code><br />
<code>QVelXYStd = .2</code><br />
<code>QVelZStd  = .4</code><br />
<code>QYawStd   = .03</code><br /></p>

<h4>5.5 Implement the EKF GPS Update function</h4>

<p>This is in UpdateFromGPS(), and it's the same idea as updating the magnetometer. This time, we use section 7.3.1 in the Udacity paper.</p>

<h4>5.6 Complete the entire simulation cycle</h4>

<p>This is a matter or repeating the Std tuning until the test passes. The values I settled on are:</p>

<p><code>QPosXYStd   = .3</code><br />
<code>QPosZStd    = .8</code><br />
<code>QVelXYStd   = .05</code><br />
<code>QVelZStd    = .13</code><br />
<code>QYawStd     = .01</code><br />
<code>GPSPosXYStd = .7</code><br />
<code>GPSPosZStd  = 2</code><br />
<code>GPSVelXYStd = .1</code><br />
<code>GPSVelZStd  = .3</code><br /></p>

<p>The simulation doesn't look very good, but the measured positions and velocities track the estimated versions, and the test passes.</p>

<p><img src="./misc/step5_a.png" alt="There should be an image here, but I can't find it." title="" /></p>

<p><code>(fcnd) [1342] jaguar: CPPEstSim</code><br />
<code>SIMULATOR!</code><br />
<code>Select main window to interact with keyboard/mouse:</code><br />
<code>LEFT DRAG / X+LEFT DRAG / Z+LEFT DRAG = rotate, pan, zoom camera</code><br />
<code>W/S/UP/LEFT/DOWN/RIGHT - apply force</code><br />
<code>C - clear all graphs</code><br />
<code>R - reset simulation</code><br />
<code>Space - pause simulation</code><br />
<code>Simulation #1 (../config/11_GPSUpdate.txt)</code><br />
<code>Simulation #2 (../config/11_GPSUpdate.txt)</code><br />
<code>PASS: ABS(Quad.Est.E.Pos) was less than 1.000000 for at least 20.000000 seconds</code><br />
<code>Simulation #3 (../config/11_GPSUpdate.txt)</code><br />
<code>PASS: ABS(Quad.Est.E.Pos) was less than 1.000000 for at least 20.000000 seconds</code><br /></p>

<p>Looking at the z position data, I think the main reason that the simulation looks so bad in real time is that the altitude updates from the GPS are so bad and coming in so slowly. To test this, I edited SimulatedSensors.txt and changed the Std Dev of the GPS altitude measurement from 2 to 0.2. I got a much better outcome.</p>

<h2>Flight Evaluation</h2>

<h3>6. Meet Performance Goals</h3>

<table border="1">
  <tr><th>CRITERIA</th><th>MEETS SPECIFICATIONS</th></tr>
  <tr>
    <td>Meet the performance criteria of each step.</td>
    <td>For each step of the project, the final estimator should be able to successfully meet the performance criteria with the controller provided. The estimator's parameters should be properly adjusted to satisfy each of the performance criteria elements.</td>
  </tr>
</table>

<p>When I went back with the "final" estimator tunings and re-ran each scenario, I found that the magnetometer test would no longer pass, and I had to reset the QyawStd variable to its former value.</p>

<p><code>QYawStd     = .08</code><br /></p>

<p>Also, I looked at the output of scenario 09, and noticed that these graphs were telling me that my "final" QPosXYStd was set too high, and the QVelXYStd was set too low. I readjusted them as below, and now all the tests pass.</p>

<p><code>QPosXYStd = .1</code><br />
<code>QVelXYStd = .2</code><br /></p>

<h3>7. Fly Successfully</h3>

<table border="1">
  <tr><th>CRITERIA</th><th>MEETS SPECIFICATIONS</th></tr>
  <tr>
    <td>De-tune your controller to successfully fly the final desired box trajectory with your estimator and realistic sensors.</td>
    <td>The controller developed in the previous project should be de-tuned to successfully meet the performance criteria of the final scenario (<1m error for entire box flight).</td>
  </tr>
</table>

<p>I copied my version of QuadControl.cpp and the associated tuning file into the estimator project, re-ran scenario 11, and as suggested by the README, my vehicle crashed prtetty quickly. So the controller needs to be detuned. The README suggests that I decrease the position and velocity gains by about 30%.</p>

<p>But I couldn't get it to work at all. Eventually, I put all of these back like they used to be:</p>

<p><code>Quad.UseIdealEstimator = 1</code><br />
<code>SimIMU.AccelStd = 0,0,0</code><br />
<code>SimIMU.GyroStd = 0,0,0</code><br /></p>

<p>And it <em>still</em> didn't work. It worked with all of the old scenarios from the conrtoller project, but not with scenario_11. This forced me to revisit my earlier controller submission. I found errors in:</p>

<p><code>RollPitchControl()</code><br />
<code>AltitudeControl()</code><br />
<code>LateralPositionControl()</code><br /></p>

<p>After correcting those errors, it was easy to de-tune the controller and get it to work with the estimator.</p>

<p><code>(fcnd) [1418] jaguar: CPPEstSim</code><br />
<code>SIMULATOR!</code><br />
<code>Select main window to interact with keyboard/mouse:</code><br />
<code>LEFT DRAG / X+LEFT DRAG / Z+LEFT DRAG = rotate, pan, zoom camera</code><br />
<code>W/S/UP/LEFT/DOWN/RIGHT - apply force</code><br />
<code>C - clear all graphs</code><br />
<code>R - reset simulation</code><br />
<code>Space - pause simulation</code><br />
<code>Simulation #1 (../config/11_GPSUpdate.txt)</code><br />
<code>Simulation #2 (../config/11_GPSUpdate.txt)</code><br />
<code>PASS: ABS(Quad.Est.E.Pos) was less than 1.000000 for at least 20.000000 seconds</code><br />
<code>^C</code><br /></p>

<p><img src="./misc/step7.png" alt="There should be an image here, but I can't find it." title="" /></p>

</body>
</html>
